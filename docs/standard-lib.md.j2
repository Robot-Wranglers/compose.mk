{% import 'macros.j2' as macros -%}

## Library Overview 

{#A Standard Library for Makefiles#}

Because `make` has never really had a standard library, there's lots of pretty basic stuff that is conspicuously missing.  This includes things like [logging and colored output](#logging-facilities), but also the kind of [online help]({{mkdocs.site_relative_url}}/cli-help) that can help you list and inspect automation that's been defined.

In library-mode, `compose.mk` is used as an `include` from your project Makefile (see the [installation docs]({{mkdocs.site_relative_url}}/integration) for more details).  After including `compose.mk`, you'll have access to a few different kinds of *make-targets, functions, and macros*.  Most of what `compose.mk` offers is in the form of reusable *static targets*, which you can directly use from the command line, or use as part of normal tasks or task-prerequisites inside your Makefile.  

In general `compose.mk` tends to avoid [make-functions](https://www.gnu.org/software/make/manual/html_node/Functions.html) because they are less reusable and composable.  But in some cases like [logging](#logging-facilities), functions might make sense.

In addition to static targets, `compose.mk` can create dynamic targets with the *`compose.import`* macro.  This can be [used with *multiple* compose files ]({{mkdocs.site_relative_url}}/multiple-compose-files), and [supports target namespacing]({{mkdocs.site_relative_url}}/macro-arguments).

Documentation for [the full target API]({{mkdocs.site_relative_url}}/api) is generated from source, and is the same as what is available from the [CLI help]({{mkdocs.site_relative_url}}/cli-help).  


{#

Regardless of whether you're using the built-in support for compose-files, `compose.mk` has many other features that extend the core capabilities of `make`, including **a curated collection of macros and reusable utility targets.  (In fact.. since make-targets always do double-duty as CLI entrypoints and as reusable task units, the "internal API" is [automatically published as a CLI interface]({{mkdocs.site_relative_url}}/tool-overview)).

Here's a brief overview of how the modules are layed out.

* **No host dependencies.** This uses the `compose.mk:tux` tool container to dockerize tmux itself.Built-in supervisor process, [improving support for signal handling](#signals-and-supervisors).
  * **Supports docker-in-docker style host-socket sharing with zero configuration,** so your TUI can generally do all the same container orchestration tasks as the docker host.
  * Open split-screen displays, shelling into 1 or more of the tool containers in k8s-tools.yml (or any other compose file).
  * Combines well with `flux.*` targets to quickly create dashboards / custom development environments.

With that in place, you have access to a few different possibilities:

1. Autogenerated **[build a bridge between docker-compose services and make-targets](#makecompose-bridge)** and [**dispatch make-targets inside tool containers.**](#container-dispatch).  
#}
<hr style="width:100%;border-bottom:3px solid black;">

### Module Layout

Here's an overview for how the `compose.mk` standard library is organized into modules: you can dive into the module or target-level documentation anywhere that looks interesting.  If you prefer a more guided tour, check out the rest of this page for a few of the random highlights.

* [**`flux.*` targets:**]({{mkdocs.site_relative_url}}/api#api-flux) A tiny but powerful workflow/pipelining API, roughly comparable to something like declarative pipelines in Jenkins[^1], providing concurrency, retry operators, etc.  You can also think of it as "target algebra" for `make`, similar to how bash provides process algebra.

* [**`tux.*` targets:**]({{mkdocs.site_relative_url}}/api/#api-tux) A control-surface for a tmux-backed console geometry manager. See the [embedded TUI docs]({{mkdocs.site_relative_url}}/embedded-tui) for a higher level overview and demos.

* [**`stream.*`:**]({{mkdocs.site_relative_url}}/api#api-stream) Support for working with streams, including newline/comma/space delimited streams, common use cases with JSON, etc.  Everything here is used with pipes, and reads from stdin.  It's not what you'd call "typed", but it reduces error-prone parsing and moves a little bit closer to structured data.

* [**`io.*`:**]({{mkdocs.site_relative_url}}/api#api-io) Misc. utilities for printing, formatting, timers, etc.

* [**`docker.*`:**]({{mkdocs.site_relative_url}}/api#api-docker) An interface for working with docker.

* [**`mk.*`:**]({{mkdocs.site_relative_url}}/api#api-docker) Meta-tooling for 'make' itself. This enables help functions, signals and supervisors, some utilities for reflection, etc.

* [**`compose.*`:**]({{mkdocs.site_relative_url}}/api#api-docker) An interface for working with compose. 

<hr style="width:100%;border-bottom:3px solid black;">

{% include "structured-io.md.j2" %}

<hr style="width:95%;border-bottom:1px dashed black;">

<hr style="width:100%;border-bottom:3px solid black;">

{% include "logging.md.j2" %}

<hr style="width:95%;border-bottom:1px dashed black;">
<hr style="width:100%;border-bottom:3px solid black;">

### Workflow Support

The flux module, aka the [**`flux.*` target namespace**]({{mkdocs.site_relative_url}}/api#api-flux), provides a tiny but powerful workflow/pipelining API, roughly comparable to something like declarative pipelines in Jenkins[^1], providing concurrency, retry operators, etc.  You can also think of it as "target algebra" for `make`, similar to how bash provides process algebra.

What `flux.*` targets add is flow-control constructs and higher-level join / loop / map instructions over *other make targets*, taking inspiration from functional programming and threading libraries. Alternatively, one may think of flux as a programming language where all primitives are the objects that make understands (e.g. targets, defines, and variables). Since every target in make is a DAG, you might say that task-DAGs are also primitives. Since `compose.import` [maps containers onto targets](#), *containers are primitives too*. Since tux targets map targets onto TUI panes, *UI elements are also effectively primitives*.  

Internally, the flux module was started as part of the support for the [the embedded TUI]({{mkdocs.site_relative_url}}/embedded-tui), but it's also useful in general.  To a certain extent you can refactor existing bash using these primitives in [stand alone mode]({{mkdocs.site_relative_url}}/tool-overview), and the next section starts by introducing concepts on the command line.  But `flux` works best with project integration where you're scripting on top of it in your own Makefiles; see [this example](#workflow-example-etl)

#### Workflow Basics

Before we get into code examples, let's introduce basic principles with the command line.

```bash 
# Introducing the `flux.ok` target:
$ ./compose.mk flux.ok
Φ flux.ok // succceeding as requested!

# Introducing the `flux.fail` target:
$ ./compose.mk flux.fail
Φ flux.fail // failing as requested!
make: *** [compose.mk:..: flux.fail] Error 1

# Since using compose.mk is the same as using `make`, 
# creating simple task DAGs works the way you expect.
# below, the 2nd target never runs, and the command fails.
$ ./compose.mk flux.fail flux.ok
① Φ flux.fail //  failing as requested!
make: *** [compose.mk:1677: flux.fail] Error 1
```

Above, `flux.ok` and `flux.fail` are just make-targets that exit with success and failure.  These are roughly equivalent to `true` and `false` in bash, so obviously there are no arguments.  You can think of `flux.ok` and `flux.fail` as placeholder targets for ones that you'll provide yourself.

For a more advanced example, let's use `flux.ok` with the autogenerated-targets for [container dispatch]({{mkdocs.site_relative_url}}/container-dispatch), and [use loadf to avoid a project Makefile]({{mkdocs.site_relative_url}}).  The following command loads the "debian" container from `tests/docker-compose.yml`, then runs the `flux.ok` target inside that tool container.

```bash 
$ ./compose.mk loadf tests/docker-compose.yml debian/dispatch/flux.ok
```

Like the dynamic `<service_name>/dispatch` target in the last example, **most targets in the `flux` module accept other targets as arguments**.  Let's introduce `flux.try.except.finally` as a simple idiom for flow-control.  This target accepts 3 comma-separated arguments for a `<try_target>`, `<fail_handler>`, and a `<always_handler>`.  Since we have `flux.ok` and `flux.fail` in hand, we'll fill in the blanks with that.

```bash 
# Demonstrate `flux.try.except`, passing in 3 comma-separated target-names as arguments.
$ ./compose.mk flux.try.except.finally/flux.fail,flux.ok,flux.ok
⇄ flux.try.except.finally // flux.fail,flux.ok,flux.ok 
Φ flux.fail //  failing as requested!
make[1]: *** [compose.mk:..: flux.fail] Error 1
Φ flux.ok //  succceeding as requested!
Φ flux.ok //  succceeding as requested!

# The semantics are what you'd expect from try/except/finally construct, 
# so the exit status is zero for success
$ echo $?
0
```

For examples of other idioms, see [flux.loop and friends]({{mkdocs.site_relative_url}}/api/#fluxlooparg), [flux.retry]({{mkdocs.site_relative_url}}/api/#fluxretryarg), [`flux.timeout`]({{mkdocs.site_relative_url}}/api/#fluxtimeoutarg), [`flux.mux`]({{mkdocs.site_relative_url}}/api/#fluxmux), etc. 

<hr style="width:95%;border-bottom:1px dashed black;">

{% include "demos/workflows.md.j2" %}

### Reflection Support

[Reflective programming](https://en.wikipedia.org/wiki/Reflective_programming) is the ability of a process to examine, introspect, and modify its own structure and behavior.

As a simple example of why this is practical, features like [CLI help](#) and [automatically generated API docs](#) require that `compose.mk` has at least *some* ability to parse its own contents.  And if we need that kind of ability, why not allow for parsing of other Makefiles?  Most of the meta-tooling that's available for stuff like this is somewhere in the [`mk.*` target namespace](#).

<hr style="width:95%;border-bottom:1px dashed black;">

#### Makefile Metadata 

For metadata parsing, you can use the `mk.parse/<fname>` target, and get back targets, target chains, target docs, etc.  

For testing, there is a super lightweight `demos/no-includes.mk` Makefile included in the repository for situations like this. Like the name suggests, it doesn't actually include or use `compose.mk` in any way.

```bash
$ ./compose.mk mk.parse/demos/no-include.mk
{
  "clean": {
    "file": "demos/no-include.mk",
    "lineno": 13,
    "chain": [],
    "type": "file",
    "docs": [""],
    "prereqs": []
  },
  "build": {
    "file": "demos/no-include.mk",
    "lineno": 14,
    "chain": [],
    "type": "file",
    "docs": [""],
    "prereqs": []
  },
  "test": {
    "file": "demos/no-include.mk",
    "lineno": 15,
    "chain": [],
    "type": "file",
    "docs": [""],
    "prereqs": []
  },
}
```

*Under the hood, the heavy lifting for Makefile-parsing uses a dockerized version of the  [`pynchon` tool](#).*

<hr style="width:95%;border-bottom:1px dashed black;">

#### Dynamic Includes and Targets

To a certain extent, `compose.mk` can do experimental *runtime* modification of `make` itself (or at least simulate it).  Under the hood, this works by code-generation to create a new Makefile just in time, and then [turning execution over to it]({{mkdocs.site_relative_url}}/signals/).  

For example, typically `make` cannot define targets dynamically, but here's an example that creates a new target on the fly, assigning it to an existing target that simply returns success.  

After the target is defined, it can be used on the same command line.

```bash 
./compose.mk mk.let/foo:flux.ok foo
```

As another example, how about fearlessly mixing `compose.mk` functionality with an existing Makefile that *does not actually `include compose.mk`*?

```bash 
$ ./compose.mk \
  mk.include/demos/no-include.mk \
  mk.let/foo:clean \
  foo
```

Pulling apart this command, let's note that the final target `foo` *does not exist* in either `compose.mk` or in the simple `demos/no-include.mk` Makefile.  And the `clean` target does not exist in `compose.mk`.  The command above basically creates and runs this non-existant Makefile just in time:

```Makefile
include compose.mk
include demos/no-include.mk
foo: clean 
DEFAULT_GOAL=foo
```

<hr style="width:95%;border-bottom:1px dashed black;">

#### Reading Defines

Reading `define ... endef` blocks from makefiles is important for several different `compose.mk` features that rely on embedded data.  And crucially, the contents of those blocks **must not be mangled**, escaped, interpolated, etc. 

`mk.def.read`

<hr style="width:95%;border-bottom:1px dashed black;">

<hr style="width:100%;border-bottom:3px solid black;">
