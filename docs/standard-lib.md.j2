{% import 'macros.j2' as macros -%}

## Library Overview 
<hr style="width:100%;border-bottom:3px solid black;">

{#A Standard Library for Makefiles#}

!!! note "Roadmap"
    Because `make` has never really had a standard library[^1], there's lots of pretty basic stuff that is conspicuously missing.  This includes things like [logging and colored output](#logging-facilities), but also the kind of [online help]({{mkdocs.site_relative_url}}/cli-help) that can list and inspect automation that's already been defined.  
    
    This page has a tutorial-style introduction to some of the more interesting capabilities.  *(If you're looking for something more like reference material, [the full target API]({{mkdocs.site_relative_url}}/api) is generated from source.)*

**In library-mode,** `compose.mk` is used as an `include` from your project Makefile (see the [installation docs]({{mkdocs.site_relative_url}}/quickstart) for more details).  After including `compose.mk`, you'll have access to a a library of make-targets and macros.  In a few cases, `compose.mk` supports "scaffolded" target that are dynamic, but that is [documented]({{mkdocs.site_relative_url}}/bridge) [elsewhere]({{mkdocs.site_relative_url}}/demos/polyglots/#foreign-code-as-first-class).  Code style considerations for both the internal library and external extensions is documented somewhat [here]({{mkdocs.site_relative_url}}/style)

Most of what `compose.mk` offers is in the form of **reusable static targets, which you can directly use from the command line**, or **use as part of normal tasks/prereqs inside your project Makefile**.  


{#In addition to static targets, `compose.mk` can create dynamic targets with the *`compose.import`* macro.  This can be [used with *multiple* compose files ]({{mkdocs.site_relative_url}}/bridge/#other-import-statements), and [supports target namespacing]({{mkdocs.site_relative_url}}/macro-arguments).#}


{#
[make-functions](https://www.gnu.org/software/make/manual/html_node/Functions.html)
Regardless of whether you're using the built-in support for compose-files, `compose.mk` has many other features that extend the core capabilities of `make`, including **a curated collection of macros and reusable utility targets.  (In fact.. since make-targets always do double-duty as CLI entrypoints and as reusable task units, the "internal API" is [automatically published as a CLI interface]({{mkdocs.site_relative_url}}/tool-overview)).

Here's a brief overview of how the modules are layed out.

* **No host dependencies.** This uses the `compose.mk:tux` tool container to dockerize tmux itself.Built-in supervisor process, [improving support for signal handling](#signals-and-supervisors).
  * **Supports docker-in-docker style host-socket sharing with zero configuration,** so your TUI can generally do all the same container orchestration tasks as the docker host.
  * Combines well with `flux.*` targets to quickly create dashboards / custom development environments.

With that in place, you have access to a few different possibilities:

1. Autogenerated **[build a bridge between docker-compose services and make-targets](#makecompose-bridge)** and [**dispatch make-targets inside tool containers.**](#container-dispatch).  
#}

### Module Layout
<hr style="width:100%;border-bottom:3px solid black;">

Here's an overview for how the `compose.mk` standard library is organized into modules: you can dive into the module or target-level documentation anywhere that looks interesting.  If you prefer a more guided tour, check out the rest of this page for a few of the random highlights.

!!! road_map "Module Layout"
    [**`flux.*` targets:**]({{mkdocs.site_relative_url}}/api#api-flux) 
    :  A tiny but powerful workflow/pipelining API, roughly comparable to something like declarative pipelines in Jenkins[^1], providing concurrency, retry operators, etc.  You can also think of it as "target algebra" for `make`, similar to how bash provides process algebra.

    [**`tux.*` targets:**]({{mkdocs.site_relative_url}}/api/#api-tux) 
    :  A control-surface for a tmux-backed console geometry manager. See the [embedded TUI docs]({{mkdocs.site_relative_url}}/embedded-tui) for a higher level overview and demos.

    [**`stream.*` targets:**]({{mkdocs.site_relative_url}}/api#api-stream) 
    :  Support for working with streams, including newline/comma/space delimited streams, common use cases with JSON, etc.  Everything here is used with pipes, and reads from stdin.  It's not what you'd call "typed", but it reduces error-prone parsing and moves a little bit closer to structured data.  See some examples [here](#structured-io-stream-types-pipes).

    [**`io.*` targets:**]({{mkdocs.site_relative_url}}/api#api-io) 
    :  Misc. utilities for printing, formatting, timers, files, etc.  Related topics include [file and stream previews](#file-and-stream-previews).

    [**`docker.*` targets:**]({{mkdocs.site_relative_url}}/api#api-docker) 
    : An small interface for working with docker.  *(See also the docs for [raw docker support]({{mkdocs.site_relative_url}}/raw-docker).)*

    [**`mk.*` targets:**]({{mkdocs.site_relative_url}}/api#api-docker) 
    :  Meta-tooling for 'make' itself. This enables help functions, signals and supervisors, some utilities for reflection, etc.  See also the [reflection docs](#reflection-support), the [packaging demo]({{mkdocs.site_relative_url}}/demos/packaging), etc.

    [**`compose.*` targets:**]({{mkdocs.site_relative_url}}/api#api-compose)
    : A small interface for working with docker compose. 

{% include "structured-io.md.j2" %}
{% include "argument-parsing.md.j2" %}
{% include "assertions.md.j2"%}
{% include "logging.md.j2" %}
{% include "workflow-support.md.j2"%}
{% include "functional.md.j2"%}
{% include "reflection.md.j2" %}
{% include "user-input.md.j2" %}

### References
<hr style="width:100%;border-bottom:3px solid black;">

[^1]: See also [GMSL](https://mxe.cc/gmsl.html), but it's mostly datastructures.
[^1]: See also jenkins [official docs](https://www.jenkins.io/doc/book/pipeline/syntax/) for pipeline syntax.
[^2]: Make-targets can be used as task-prerequisites as well as command line entrypoints.
[^3]: https://github.com/h4l/json.bash
[^4]: https://github.com/jqlang/jq
[^5]: https://github.com/mikefarah/yq
[^6]: Yes, technically JSON is only "semi-structured" without additional schema commitments, etc
[^7]: [Homoiconic?]({{mkdocs.site_relative_url}}/language#homoiconic)
[^8]: [See for example the `jc` tool](https://kellyjonbrazil.github.io/jc/)

<script>
document.addEventListener('DOMContentLoaded', function() {setTimeout(function() {
	addImageToHeader('library-overview','/{{mkdocs.config.site_name}}/img/overview.svg')
}, 100);});
</script>
