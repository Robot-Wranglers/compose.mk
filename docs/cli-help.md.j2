{% import 'macros/base.j2' as macros -%}{% import 'macros/site.j2' as site -%}

## CLI Help
<hr style="width:100%;border-bottom:3px solid black;">

When using `compose.mk` directly, help not only *works,* it goes beyond simply listing available targets, and actually parses and displays documentation per target, and per target-namespace. Python-style docstrings are supported for targets, and markdown in those docstrings is supported and rendered.  Here are some ways to ask for help:

```bash {.cli_example}
# List all targets 
$ ./compose.mk help

# Pretty-print help for a single target 
$ ./compose.mk help/docker.run

# Works for multiple targets, using prefix search
$ ./compose.mk help/docker

# Adding arguments directly with no slash also works if using `compose.mk` directly,
# but project Makefiles cannot inherit this by including compose.mk as a library
./compose.mk help docker
```

{{macros.img_link("cli-help.gif", mkdocs, "90%",class='cli_output')}}

Under the hood, help uses a dockerized version of [mk.parse](https://github.com/mattvonrocketstein/mk.parse) and [charmbracelete/glow](https://github.com/charmbracelet/glow).  Because this uses containers, be advised that rendering help can be slow, especially the first time it runs.  See the [implementation details section](#implementation-details) for more about this, and other hints for granular access to the moving pieces involved here.

### Help For Project Makefiles
<hr style="width:100%;border-bottom:3px solid black;">

To enable help your project Makefile, there are a few options depending on how tightly you want to integrate, but usually it's enough to just `include compose.mk` somewhere near the top of your file.

```bash {.cli_example}

# List only targets that are static and local, i.e.
# targets which are not scaffolded, and are not included from other Makefiles
$ make help.local

# Pretty-print help for a single target or prefix
$ make help.local/build

# Print all help for all local targets
$ make help.local.all
```

#### Docstring Style 
<hr style="width:95%;border-bottom:1px dashed black;">

Note that for help to render properly, your targets need to use the following style for comments, similar to python-style docstrings.  *(There is no support for other kinds of comments that are above or inside of target-bodies.)*

{{site.embed_demo('demos/cli-help.mk', github=github)}}

{#
#### Basic Integration
<hr style="width:95%;border-bottom:1px dashed black;">

The file above is exercised as part of the test-suite, and is *actually* called `demos/cli-help.mk`, and invoked with `./demos/cli-help.mk`.  For the sake of the next examples though, we'll pretend it's your project Makefile and simply invoked as `make ...`.

With a simple setup like this, here's what's enabled:


```bash {.cli_example}
# Display a FULL list of new-line separated targets,
# most of which are inherited via the `include` statement
$ make help

# Abbreviated list of newline-separated LOCAL targets (no includes)
$ make mk.targets

# Rendered help for all local targets (potentially very slow)
$ make help.local.all

# Rendered help for 1 target 
$ make mk.help.target/my-target
```

#### Full Integration
<hr style="width:95%;border-bottom:1px dashed black;">

With the basic integration so far, we haven't yet seen the kind of help for extensions that we started with for `compose.mk`, i.e. `./compose.mk help <target_or_module>`.

Since `make help.local` actually renders *all* help strings for all local targets, you may find that invocations like `make help <target>` are not that useful.  In fact.. for technical reasons related to default argument parsing by `make`[^1],  invocations like `make help <target>` **cannot work with project makefiles** because the target would actually be executed.

There are a few ways to work around this.

```bash {.cli_example}
# use `mk.parse/<fname>` to get all Makefile metadata, including help.  (returns JSON)
$ ./compose.mk mk.parse/demos/cli-help.mk


# use `mk.interpret` to wrap another Makefile, then proxy help commands the wrapper.
$ ./compose.mk mk.interpret demos/cli-help.mk help my-target
```

The last command mentions an interpreter, which is discussed in more detail in the [supervisors and signals docs]({{mkdocs.site_relative_url}}/signals).  For our purposes here, the main point though is just that the `help <target>` part is working again. 

---------------------

Going further.. we can actually setup `compose.mk` as the interpreter more directly and mention it in a [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).  In the next example, only the first line of the file changes:

{{site.embed_demo('demos/cli-help-shebang.mk', github=github)}}

Now `./demos/cli-help-shebang.mk help my-target` works as expected.  An approach like this will also work if the file is named `Makefile`, but note that **the shebang is ignored unless you execute the file directly**!
#}

### Implementation Details
<hr style="width:100%;border-bottom:3px solid black;">

Since help involves targets and target-metadata, it's also a special case of reflection, which you can read more about [in the standard-library docs]({{mkdocs.site_relative_url}}/standard-lib/#reflection-support).

{#
The implementation for help uses the `mk.help.*` family of targets, and if you want to customize help or error messages they might be useful.  

{{site.api_link_many(['mk.help'],mkdocs)}}
#}
Heavy lifting for parsing metadata comes from a dockerized version of the mk.parse tool[^1] which extracts and displays docstrings, as well as other details like target-prerequisites.  

To see example output or just precache the `mk.parse` container, you can use {{site.api_link('mk.parse',mkdocs,arg='some_makefile')}}.  To get an idea about the schema, we can use `compose.mk` to parse it's own content, then show the JSON structure for the `mk.parse` target itself.


```bash {.cli_example}
$ ./compose.mk mk.parse/compose.mk
```
```json {.language-json .cli_output}
{
  ..
  "mk.parse/%": {
    "file": "compose.mk",
    "lineno": 2323,
    "parametric": true,
    "docs": [
      " Parses the given Makefile, returning JSON output that describes the targets, docs, etc.",
      " This parsing is \"deep\", i.e. it returns docs & metadata for *included* targets as well.",
      " This uses a dockerized version of the mkparse[1] tool.",
      "",
      " REFS:",
      "   * `[1]`: https://github.com/mattvonrocketstein/mk.parse/"
    ],
    "prereqs": [],
    "local": true,
    "private": false,
    "regex": "mk.parse/.*",
    "implementors": []
  },
  ..
```

### References
<hr style="width:100%;border-bottom:3px solid black;">

[^1]: [mk.parse tool]({{jinja.vars.mkparse_repo_url}}/)

<script>
document.addEventListener('DOMContentLoaded', function() {setTimeout(function() {
	addImageToHeader('cli-help','/{{mkdocs.config.site_name}}/img/user.svg')
	addImageToHeader('implementation-details','/{{mkdocs.config.site_name}}/img/implementation.svg')
}, 100);});
</script>