{% import 'macros.j2' as macros -%}

## Language Overview
<hr style="width:100%;border-bottom:3px solid black;">

You might already be aware that `compose.mk` offers a [standard library for working with `make`]({{mkdocs.site_relative_url}}/standard-lib), a sort of stand-alone [tool mode]({{mkdocs.site_relative_url}}/tool-overview), and [a TUI framework]({{mkdocs.site_relative_url}}/embedded-tui), but now you've reached the page that will finally reveal the shocking secret truth: **compose.mk is actually a programming language!** ðŸ˜® 

More to the point though, `compose.mk` is a matrioshka language, and maybe the *first one that's actually intended to be useful*.  See the [matrioshka automata page]({{mkdocs.site_relative_url}}/matrioshka) to get more information about patterns for packing programs inside of programs.  

This page focuses on other language-related features and **also serves as an alternate to the [main landing page]({{mkdocs.site_relative_url}}/overview)** for people who prefer their overviews to focus less on applications and more on **theory, architecture, and patterns**.

### Language Properties
<hr style="width:100%;border-bottom:3px solid black;">

**As a language,** you could say that `compose.mk` is and has the following properties:

* Inherits macros, declarative style, and basic DAGs[^2] from `make`
* Inherits tacit programming[^3] from the unix shell
* Supports reflective programming[^4] via e.g. [mk.*]({{mkdocs.site_relative_url}}/standard-lib/#reflection)
* Supports extensible programming[^5]
    * via container support generally, but also 
    * via [polyglots]({{mkdocs.site_relative_url}}/demos/polyglots) and 
    * via [dynamically]({{mkdocs.site_relative_url}}/container-dispatch/#namespace-style-dispatch) [assigned syntax]({{mkdocs.site_relative_url}}/compiler/#user-defined-extensions)
* Supports functional programming[^6] and data flow programming[^7] via [flux]({{mkdocs.site_relative_url}}/api#api-flux), [flux workflows]({{mkdocs.site_relative_url}}/demos/workflows), [etc]({{mkdocs.site_relative_url}}/demos/platform)
* Inclines towards concatenative style[^8] and stack-oriented programming[^9]
    * partly via default `make` target execution semantics
    * partly via [compose.mk stage-stacks]({{mkdocs.site_relative_url}}/stage)
* Supports [structured data]({{mkdocs.site_relative_url}}/standard-lib#structured-io) and makes [extensive use of streams]({{mkdocs.site_relative_url}}/standard-lib)
* Supports *some* OOP implicitly, 
    * via container layers, or via yaml inheritance in composefiles
    * via make-includes, via target-chaining, via syntax conventions for target names, etc

Further, you could say that `compose.mk` is an interpreted language that is implemented *in* `make`, but in some sense it also runs *on* `make` by hijacking it as a kind of [gadget](https://en.wikipedia.org/wiki/Gadget_(computer_science)).  

{#Related topics include the [support for packaging]({{mkdocs.site_relative_url}}/demos/package), which combines well with the sheer ubiquity of `make`, effectively allowing us to **release frozen artifacts** in a way that is similar to compilation.#}

### Homoiconic?
<hr style="width:100%;border-bottom:3px solid black;">

Let's introduce a somewhat surprising fact: `compose.mk` is designed to be [homoiconic](https://en.wikipedia.org/wiki/Homoiconicity) on `make` targets, at the same time as it generalizes what targets can *be*.  Thus among other things, a `compose.mk` target can:

1. Execute directly (default behaviour for `make`)
1. Group other tasks into DAGs (default behaviour for `make`)
1. Serve as a *handle* for a container's default entrypoint (via [`compose.import`]({{mkdocs.site_relative_url}}/bridge))
1. Execute inside of containers (via [container dispatch]({{mkdocs.site_relative_url}}/container-dispatch))
1. Execute later, conditionally, or repeatedly etc (via [flux]({{mkdocs.site_relative_url}}/standard-lib#workflow-support))
1. Describe data-flow and/or control-flow across other tasks (again via [flux]({{mkdocs.site_relative_url}}/standard-lib#workflow-support))
1. Execute arbitrary tasks in foreign languages (via [polyglots]({{mkdocs.site_relative_url}}/demos/polyglots))

In the [workflow docs]({{mkdocs.site_relative_url}}/standard-lib/#workflow-support), the `flux.*` namespace is introduced as a "target algebra", and compared to shell process algebra.  But as a simple example of "targets all the way down" consider this:

* {{macros.api_link('flux.wrap',mkdocs,arg='targets')}} is a n-ary target that accepts nullary targets as arguments.
* Meanwhile.. {{macros.api_link('flux.ok',mkdocs)}} and {{macros.api_link('flux.fail',mkdocs)}} are examples of nullary targets.
* But invocation, like say `flux.wrap/flux.ok,flux.fail`, is itself also a (nullary) target.

Of course, no matter how easily you can incorporate foreign tools.. at some point, you might also need to write **task implementations** rather than just glue, *i.e. actual target bodies in shell, or polyglots in foreign languages*.  Nevertheless.. you'll probably be surprised by how infrequently that's actually necessary, and when it is, how small the task-implementations you need actually are.  For a quick example of how much you can accomplish with no target bodies at all, see also the docs for [low config TUIs]({{mkdocs.site_relative_url}}/low-config-tuis/).

### Interpreters & Transpilation
<hr style="width:100%;border-bottom:3px solid black;">

By the way, since the claim is that something like `flux.wrap/flux.ok,flux.fail` is actually "a program" in a "language" though, it's worth pointing out that there are many ways to execute it beyond mentioning it in a Makefile as a target-prerequisite.  The following are all equivalent, but the last example demonstrates what you can think of as the `compose.mk` interpreter.

```bash 
# program as target
$ make -f compose.mk flux.wrap/flux.ok,flux.fail

# program as subcommand
$ ./compose.mk flux.wrap/flux.ok,flux.fail

# program as code
$ echo flux.wrap/flux.ok,flux.fail | ./compose.mk mk.kernel
```

The example above is simplistic, but there are other ways that `compose.mk` can [act as an interpreter]({{mkdocs.site_relative_url}}/signals/#inheritance-interpreters), and even support transpilation for a *syntactically different* language that transforms to classical Makefile.  For more details, see the [Compiler & Dialects docs]({{mkdocs.site_relative_url}}/compiler).

<hr style="width:95%;border-bottom:1px dashed black;">

[^2]: https://en.wikipedia.org/wiki/Directed_acyclic_graph
[^3]: https://en.wikipedia.org/wiki/Tacit_programming
[^4]: https://en.wikipedia.org/wiki/Reflective_programming
[^5]: https://en.wikipedia.org/wiki/Extensible_programming
[^6]: https://en.wikipedia.org/wiki/Functional_programming 
[^7]: https://en.wikipedia.org/wiki/Dataflow_programming
[^8]: https://en.wikipedia.org/wiki/Concatenative_programming_language 
[^9]: https://en.wikipedia.org/wiki/Stack-oriented_programming
