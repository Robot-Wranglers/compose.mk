{% import 'macros.j2' as macros -%}

### Functional Style
<hr style="width:100%;border-bottom:3px solid black;">

We've met several concepts borrowed from functional programming constructs already.  Sometimes aliases are in place to make this more clear.. for example, the `flux.and` and `flux.or` just different names for `flux.all` and `flux.any`.  A version of `flux.each` that works directly with args instead of streaming input is called `flux.for.each`, aka {{macros.api_link('flux.map', mkdocs, arg='args')}}.  

#### Apply, Map, Starmap
<hr style="width:95%;border-bottom:1px dashed black;">

Functional friends like **apply, starmap, etc** are available:

```bash {.cli_example .language-bash}
$ ./compose.mk flux.map/flux.echo,hello,world
```
```markdown {.cli_output}
hello
world
```

```bash {.cli_example .language-bash}
$ ./compose.mk flux.apply/flux.echo,hello-world
```
```markdown {.cli_output}
hello-world
```

The {{macros.api_link('flux.starmap', mkdocs, arg='fxn,generator')}} takes 2 arguments, then applies the function to each value generated by generator.  Demonstrating this with *only other builtins* isn't very practical.. but one of the things you can do is unpack `flux.map`.

```bash {.cli_example .language-bash}
# Itertools-ish or generators
$ ./compose.mk flux.starmap/flux.echo,flux.map/flux.echo,hello,world
```
```markdown {.cli_output}
hello
world
```

An analog to **function composition** can be achieved with {{macros.api_link('flux.pipeline',mkdocs,arg='targets')}}, but the functions involved downstream (in our case {{macros.api_link('stream.echo',mkdocs)}}) need to accept pipes.

```bash {.cli_example .language-bash}
# Pipelines are function composition.
#
$ ./compose.mk flux.pipeline/flux.echo/hello,stream.echo
```
```markdown {.cli_output}
hello
```

#### Partial Functions
<hr style="width:95%;border-bottom:1px dashed black;">

Partials are not very difficult to get with vanilla `make`, and that approach is generally better.

However `__flux.partial__` adds another kind of support focused on quick partials for binary functions.  See the snippet below:

{{macros.embed_demo('demos/partials.mk', github=github)}}

#### Other Operators
<hr style="width:95%;border-bottom:1px dashed black;">

Sorry, **reduce and fold operators** are deliberately ommitted as they don't often find use-cases in automation.  If this fills you with sadness, there is the consolation prize that [signals in compose.mk]({{mkdocs.site_relative_url}}/signals) are somewhat like **call/cc** =P  

Topics related to **currying** are explored a bit in the discussion [of style]({{mkdocs.site_relative_url}}/style/#performance-and-currying) for lack of a better place.  

<script>
document.addEventListener('DOMContentLoaded', function() {setTimeout(function() {
	addImageToHeader('functional-style','/{{mkdocs.config.site_name}}/img/lambda.svg')
}, 100);});
</script>
