{% import 'macros.j2' as macros -%}

## About Style
<hr style="width:100%;border-bottom:3px solid black;">

Style should be practical rather than prescriptive, but here's a few things that seem worth writing down.  This page will probably grow over time.

### Internal Style 
<hr style="width:100%;border-bottom:3px solid black;">

**In terms of interface and in terms of internal *style***, `compose.mk` tends to avoid macros and other fancy Makefile'isms as much as possible because compared with targets, they are more magical, less reusable, and less composable.  Still, there are many places where compromising on this makes sense. 

1. For [logging](#logging-facilities), [autogenerated target scaffolding]({{mkdocs.site_relative_url}}/bridge), etc, we can't really avoid `$(call ..)`.  
1. Sometimes macros actually **improve** readability (for example writing *`${stream.stdin}`* instead of *`cat /dev/stdin`*). We adopt those approaches for clarity in places where they seem self-documenting.
1. Macro expansion is also used sometimes as an optimization to avoid extra processes.  Still, macros are basically safe to ignore, because in most cases there's a target-equivalent available.

### Style for Extensions 
<hr style="width:100%;border-bottom:3px solid black;">

**In terms of style for extensions,** there's a range of options with most things.  In the spirit of pragmatism over prescription.. you'll probably want to choose based on what/who you're already working with.  Depending on your apetite for magic / syntactic sugar, you can opt for:

* Explicit container dispatch *(i.e. [typical usage]({{mkdocs.site_relative_url}}/container-dispatch)`<container>.dispatch/<target>`)*
* Implicit container dispatch *(i.e. [namespace-style dispatch]({{mkdocs.site_relative_url}}/container-dispatch/#namespace-style-dispatch)*
* Explicit polyglot invocation *(i.e. [less magic]({{mkdocs.site_relative_url}}/demos/polyglots/#containerized-interpreters))* 
* Implicit polyglot invocation *(i.e. [more magic]({{mkdocs.site_relative_url}}/demos/polyglots/#foreign-code-as-first-class))*

For new development though, implicit style is often more idiomatic and namespace-style dispatch is usually recommended.  *(See especially the [platform lifecycle demo]({{mkdocs.site_relative_url}}/demos/platform/) for clean and practical example usage with a concrete problem.)*

Revisiting the earlier idea that "sometimes macros improve readability" and targets with equivalent macros, there's a similar choice about implicit vs explicit style:

```Makefile
include compose.mk 

explicit:
	${make} <some_target>/<some_arg>

implicit:
	${some_target}/<some_arg>
```

When a target is used often enough, the explicit style becomes tedious to read and write.  So *whenever it won't confuse someone else* an implicit style might be preferred, especially for larger programs.

### From Style to Dialect
<hr style="width:100%;border-bottom:3px solid black;">

Somewhere at the limit of style, syntax, and sugar you run into ideas like dialects[^1], extensible programming[^2], language-oriented programming[^3] and DSLs.  To support this type of thing, [CMK-lang actually allows for direct control of some aspects of the language syntax]({{mkdocs.site_relative_url}}compiler/#user-defined-extensions).  See also the [main docs for Compiler & Dialects]({{mkdocs.site_relative_url}}/compiler).

<hr style="width:100%;border-bottom:3px solid black;">

[^1]: https://en.wikipedia.org/wiki/Programming_language#Dialects,_flavors_and_implementations
[^2]: https://en.wikipedia.org/wiki/Extensible_programming
[^3]: https://en.wikipedia.org/wiki/Language-oriented_programming
