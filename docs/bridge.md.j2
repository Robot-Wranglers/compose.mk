{% import 'macros.j2' as macros -%}

## Import Services from Compose

<hr style="width:100%;border-bottom:3px solid black;">

One of the main features for `compose.mk` is a method for "importing" one [or more]({{mkdocs.site_relative_url}}/bridge/#other-import-statements) docker compose files into your project Makefile.  This uses the `compose.import` macro to automatically generate related make-targets for each docker-compose service.  Sometimes this "importing" process is referred to as *automation scaffolding*, or we might refer to it as *the make/compose bridge* or simply *the bridge*.

Usually it's better to separate the details of automation / execution environment, but technically you can also [embed compose service definitions directly]({{mkdocs.site_relative_url}}/demos/matrioshka/#inlined-compose-files) and generate scaffolding from that too.

<hr style="width:95%;border-bottom:1px dashed black;">

Let's walk through a minimal example, starting with a sample compose file.  

We'll use images for debian and alpine just as examples, but these might be any tool containers that your workflow requires.

```yaml 
{{open('demos/data/docker-compose.minimal.yml','r').read().strip()}}
```

<hr style="width:95%;border-bottom:1px dashed black;">

Next, the Makefile.  To generate make-targets for every service in the given compose file, we just need to include `compose.mk` as a library, then call one of the `compose.import.*` functions.

```Makefile
# Inside your project Makefile
include compose.mk
$(eval $(call compose.import, docker-compose.yml))
```

The simplest way to use `compose.import` is with a single argument that passes in a compose-file.  

{#
and specifying we want services-handles as the top-level, plus an optional namespace for .
By default, you'll get 
The arguments *`(some_namespace, TRUE)`* above allow for control of the scaffolding's namespace and syntax.  *(More on that later in the [Macro Arguments section](#macro-arguments).)*  The final argument is just the (unquoted!) name of the file you want to import services from. 
<hr style="width:95%;border-bottom:1px dashed black;">

but The 2nd argument *TRUE* is a bool for whether `compose.import` was allowed to import to the root namespace, you get top-level targets for each service.
#}

That's it for the minimal boilerplate, but we already have lots of interoperability for the containers involved.  This includes stuff like:

* The ability to quickly shell into these containers 
* The usual `docker compose` verbs like *stop/start/up/exec/logs*
* And crucially, *the ability to easily pass in data on pipes*.

See the next section for details about the autogenerated targets, or, if you're interested in running tasks inside of the compose-services skip ahead to the [container-dispatch section]({{mkdocs.site_relative_url}}/container-dispatch).

{# <hr style="width:95%;border-bottom:1px dashed black;">} #}

### Target Scaffolding
<hr style="width:100%;border-bottom:3px solid black;">

Targets created as part of the automation scaffolding fall into the following categories.


#### Top-level Container Handles
--------------------

Top level container handles are targets that are created in the root namespace, basically mirroring the familiar verbs for docker compose ( *up/down/build/stop/ps/logs* ), plus adding conveniences for things like piping and shells.

* [**`<svc_name>`**](#svc_name): Runs the container with default entrypoint
* [**`<svc_name>`.shell**](#svc_nameshell): Drops into an interactive shell for this container
* [**`<svc_name>`.shell.pipe**](#svc_nameshellpipe): Pipe data into the container shell
* [**`<svc_name>`.get_shell**](#svc_namespecial): Try to detect a usable shell for the container
* [**`<svc_name>`.dispatch/<target>**](#svc_namedispatch): Runs the given target inside the given container
* [**`<svc_name>`.build**](#svc_namebuild): -> roughly `docker compose -f .. build` 
* [**`<svc_name>`.logs**](#svc_namespecial): -> roughly `docker compose -f .. logs` 
* [**`<svc_name>`.ps**](#svc_namespecial): -> roughly `docker compose -f .. ps` 
* [**`<svc_name>`.stop**](#svc_namestop): -> roughly `docker compose -f .. stop` 
* **...**

So for our simple example so far, `svc_name` would be either `debian` or `alpine`.

Using `compose.import` creates top-level handles automatically, but there are other [namespace management options](#) to avoid collisions.


#### Canonical Names
------------------------
 
 **Canonical name** targets are sort of like "absolute paths" to the ones mentioned above, plus additional "group" targets that work with all of the services at the same time.

{#
Regardless of whether you're importing to the root namespace, you'll get "absolute paths" to similar targets that are created automatically.  For example:
#}

* [**`<compose_stem>`.services**](#compose_stemspecial): -> roughly `docker compose -f .. config --services`
* [**`<compose_stem>`.build**](#compose_stemspecial): -> roughly `docker compose -f .. build` 
* [**`<compose_stem>`.clean**](#compose_stemspecial): -> roughly `docker compose -f .. down --rm-orphans --rmi` 
* [**`<compose_stem>`/`<svc_name>`.`<verb>`**](#), i.e. the same as the **toplevel container handles**.

So for our example so far, `compose_stem` from `docker-compose.yml`would be `docker-compose`.

Canonical names are always created unconditionally with `compose.import` or [any other kind of import statement](#other-import-statements).

#### Dispatch Namespace 
--------------------------

User-provided dispatch-namespaces are optional, but often a good idea.  In addition to most of the "group" targets available as **canonical names**, you get [syntactic sugar for target dispatch]({{mkdocs.site_relative_url}}/container-dispatch/#namespace-style-dispatch).

* `<namespace>/<svc>/<target>`: -> roughly `<svc_name>.dispatch/<target>`

Be aware that import-statements that do not explicitly *provide* user-namespaces still have one, but use the default value of `services`.  (Really we expect tool-containers.. but this is in deference to the config-key name used by the docker-compose spec.) 

See the [full docs for compose.import](#other-import-statements) and the [main container dispatch docs]({{mkdocs.site_relative_url}}/container-dispatch) for more information. 

### Bridge API
<hr style="width:100%;border-bottom:3px solid black;">

#### **[â‡›](#svc_nameshell) `<svc_name>`.shell**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.shell** target drops to a containter shell for the named service, and is usually interactive.

```bash 

# Interactive shell on debian container
$ make debian.shell

# Interactive shell on "alpine" container
$ make alpine.shell
```

{{macros.img_link("demo-bridge-shell.gif", mkdocs)}}


#### **[â‡›](#svc_namebuild) `<svc_name>`.build**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.build** target explicitly builds containers.  This is for convenience, but usually it's fine to let this happen implicitly or just in time.

```bash
# Build debian container (respects cache)
$ make debian.build

# Force-build debian container (busts cache)
$ force=1 make debian.build
```

#### **[â‡›](#svc_nameps) `<svc_name>`.ps**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.ps** target is roughly `docker compose -f .. <svc> ps`.

```bash
# Shows results for running instances
$ make debian.ps

# Require results for running instances, failing otherwise
$ strict=1 make debian.ps
```

#### **[â‡›](#svc_namelogs) `<svc_name>`.logs**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.logs** target is roughly `docker compose -f .. <svc> logs`.

```bash
# Shows results for running instances
$ make debian.logs

# Require results for running instances, failing otherwise
$ strict=1 make debian.ps
```

#### **[â‡›](#svc_namedispatch) `<svc_name>`.dispatch**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.dispatch** target is unary rather than nullary like our other examples. It accepts as an argument a target to run in the given container.  See the [container dispatch docs](#) for more details, but in this example we'll just pass in the trivial target {{macros.api_link('flux.ok',mkdocs)}}.

```bash
# Shows results for running instances
$ make debian.dispatch/flux.ok
```

#### **[â‡›](#svc_nameshellpipe) `<svc_name>`.shell.pipe**
<hr style="width:95%;border-bottom:1px dashed black;">

The ***svc_name*.shell.pipe** target allows streaming data:

```bash
# Stream commands into debian container
$ echo uname -n -v | make debian.shell.pipe

# Equivalent to above, since the debian image's default entrypoint is bash
$ echo uname -n -v | make debian.pipe

# Streams command input / output between containers
echo echo echo hello-world | make alpine.pipe | make debian.pipe
```

{{macros.img_link("demo-bridge-stream.gif", mkdocs)}}

#### **[â‡›](#svc_name) `<svc_name>`**
<hr style="width:95%;border-bottom:1px dashed black;">

The top-level **svc_name** targets are more generic and can be used without arguments, or with optional explicit overrides for the compose-service defaults.  Usually this isn't used directly, but it's sometimes useful to call from automation. Indirectly, most other targets are implemented using this target.

```bash 
# Runs an arbitrary command on debian container (overriding compose defaults)
$ entrypoint=ls cmd='-l' make debian

# Streams data into an arbitrary command on alpine container
$ echo hello world | pipe=yes entrypoint=cat cmd='/dev/stdin' make alpine
```


#### **[â‡›](#svc_namespecial) `<svc_name>`/`<special>`**
<hr style="width:95%;border-bottom:1px dashed black;">

Besides targets for working *with* services there are targets for answering questions *about* services.

The *`<svc_name>.get_shell`* targets answers what shell can be used as an entrypoint for the container. Usually this is `bash`, `sh`, or an error, but when there's an answer you'll get it in the form of an absolute path.

```bash

$ make debian.get_shell
/bin/bash
```

#### **[â‡›](#svc_compose_stemsvc) `<compose_stem>/<svc>`**
<hr style="width:95%;border-bottom:1px dashed black;">

Namespaced aliases are also available, so that you can reference compose services by something like an "absolute path".  Due to the file-stem of the compose file we imported, all of the stuff above will work on targets like you see below. 

```bash
$ make docker-compose/debian
$ make docker-compose/debian.shell
```

#### **[â‡›](#svc_compose_stemcmd) `<compose_stem>`.`<cmd>`**
<hr style="width:95%;border-bottom:1px dashed black;">

Besides targets for working with compose-services, some targets work on the compose file itself.  Assuming your compose file is named `docker-compose.yml`, the special targets work like this:

```bash 

# Build (equivalent to `docker compose -f docker-compose.yml build`)
$ make docker-compose.build

# Build (equivalent to `docker compose -f docker-compose.yml stop`)
$ make docker-compose.stop

# Clean (equivalent to `docker compose -f docker-compose.yml down --remove-orphans`)
$ make docker-compose.clean

# List all services defined for file (Array of strings, xargs-friendly)
$ make docker-compose.services
```

Using the `<compose_stem>.services` target, it's easy to map a command onto every container.  Try something like this:

```bash 
$ make docker-compose.services \
  | xargs -n1 -I% sh -x -c "echo uname -n \
  | make docker-compose/%.shell.pipe"
```

### Other Import Statements
<hr style="width:100%;border-bottom:3px solid black;">

So far, we've stuck to the simplest syntax for `$(call compose.import, docker-compose.yml)`, but there's a few ways to do this.  


#### **Root + Namespace**
----------------------

Here's a variation that configures [syntactic sugar for dispatch namespaces]({{mkdocs.site_relative_url}}/container-dispatch/#namespace-style-dispatch), by providing a 2nd argument to `compose.import`.

```Makefile
include compose.mk
$(eval $(call compose.import, path/to/docker-compose.yml, my_namespace))
```


#### **Namespace Only**
----------------------

Recall that `compose.import` as used above defaults to creating top level targets.  

To configure a user-provided dispatch namespace and **not** import targets to the root.. use `compose.import.as`

```Makefile
include compose.mk
$(eval $(call compose.import.as, my_namespace, path/to/docker-compose.yml))
```


#### **Multiple Compose Files**
----------------------

The namespace-only style is perhaps the most useful for working with multiple compose files, and is an effective way to organize your tool containers into different "tool boxes" at the docker-compose level in case you want one for build tools, one for docs, etc.

```Makefile
include compose.mk

# Load 1st compose file under paralleogram namespace,
$(eval $(call compose.import.as, â–°, my-compose-files/build-tools.yml))

# Load 2nd compose file under triangle namespace
$(eval $(call compose.import.as, â–², my-compose-files/cluster-tools.yml))

# Top-level "build" target that dispatches subtargets
# "build-code" and "build-cluster" on different containers
build: â–°/maven/build.code â–²/kubectl/build.cluster
build.cluster:
  kubectl .. 
build.code:
  maven ...
```

There's lots of ways to use this.  And if your service names across 2 files do not collide, you are free to put everything under exactly the same namespace.  It's only syntax, but if you choose the conventions wisely then it will probably help you to think and to read whatever you're writing.

{#
Confused about what targets are available after using `compose.import`?  

See the [`<compose_stem>.services`](/compose.mk/bridge/#compose_stemcmd) for list services, and check out the `make help` output.
#}


#### **Inlined / Embedded / From-String** 
----------------------

So far, we've been working with files, but generating target-scaffolding can also work on strings, i.e. with [embedded compose files]({{mkdocs.site_relative_url}}/demos/matrioshka).  See that documentation for examples, but below you can find the basic usage.  Note that "namespace" is implied, because it always the same as the define-block's name.

```Makefile
include compose.mk

define embedded_services
...
endef

$(eval $(call compose.import.string, embedded_services))

# To disable import to the root namespace, pass `FALSE` for 2nd argument.
# $(eval $(call compose.import.string, embedded_compose.yml, FALSE))

```


#### **Generic Import**
----------------------

Finally, let's introduce `compose.import.generic`, which you probably don't need to use directly, but which all of the above are using under the hood.

```Makefile
include compose.mk
$(eval $(call compose.import.generic, <namespace>, <bool_import_to_root>, <fname>))
```

<br/>

{#
A related topic is [importing foreign code]({{mkdocs.site_relative_url}}/demos/polyglots/#foreign-code-as-first-class) as a first class object, 

See also the docs for [container dispatch syntax/semantics]({{mkdocs.site_relative_url}}/container-dispatch/#dispatch-syntaxsemantics).

**The 1st argument for `compose.import` is called `target_namespace`**.  You can swap the unicode for `â–°` out, opting instead for different symbols, path-like prefixes, whatever.  If you're bringing in services from several compose files, one way to control syntax and namespacing is to use different symbols for different calls to `compose.import`.  (For a two-file example, see the [Multiple Compose Files]({{mkdocs.site_relative_url}}/bridge/#other-import-statements) section.)

**The 2nd argument for `compose.import` controls whether service names are available as top-level Makefile targets.**  The only value that means True is *`TRUE`*, because Make isn't big on bool types.  Regardless of the value here, service targets are always under `<compose_file_stem>/<compose_service_name>`. 

**The last argument for `compose.import` is the compose-file to load services from.**  It will be tempting to quote this and the other arguments, but that won't work, so resist the urge!
#}

### But Why? ðŸ¤”
<hr style="width:100%;border-bottom:3px solid black;">

At first glance, maybe you're thinking this looks like lots of magic to save a little bit of typing.  It's true that this method of "importing" compose services as `make` targets is often just paving the way for [container dispatch]({{mkdocs.site_relative_url}}) later.

Even without dispatch though, native support for containers as primitives is useful, especially when you start to use **actions on those containers as prerequisite tasks**.  So far we've seen that scaffolded targets effectively create an API over tool containers, but what's not emphasized yet is just how composable that API really is.

If you're unconvinced on this point, you might want to skip ahead to some more advanced stuff that is digging into this topic like [the TUI docs]({{mkdocs.site_relative_url}}/embedded-tui) or [other tutorials]({{mkdocs.site_relative_url}}/demos/notebooking).

### Import Macro Implementation
<hr style="width:100%;border-bottom:3px solid black;">

For the curious who are unfamiliar with esoteric `make`, let's unpack the incantation: 

```Makefile 
$(eval $(call compose.import.generic, â–°, TRUE, docker-compose.yml))
```

The [`eval`](https://www.gnu.org/software/make/manual/html_node/Eval-Function.html) / [`call`](https://www.gnu.org/software/make/manual/html_node/Call-Function.html) combination is how you can give `make` dynamic targets.  This is basically a code-generation step, where `compose.import.generic` is basically a templated string, and then using `call` binds the values `( â–°, TRUE, docker-compose.yml)` as template parameters.  *Since the templated string happens to render to legal Makefile syntax*, the call to `eval` results in the declaration of new concrete targets.

Of course, understanding this isn't required to *use* it.. and metaprogramming in `make` like this is something that's always guaranteed to inspire strong feelings of horror or of delight.  If you're *that* type of weirdo, you might like to [read more about the technique here](https://make.mad-scientist.net/the-eval-function/).

<hr style="width:100%;border-bottom:3px solid black;">
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Wait for MkDocs to fully render the page including ToC
    setTimeout(function() {
        const heading = document.getElementById('import-services-from-compose');
        const img = document.createElement('img');
        img.style.height = '2em'; img.style.verticalAlign = 'bottom';
        img.src = '../img/compose.png'; 
        heading.insertBefore(img, heading.firstChild);
        img.style.marginRight = '10px';
        //img.style.marginLeft = '10px';
        //heading.appendChild(img);
    }, 100); // Small delay to ensure ToC is already processed
});
</script>