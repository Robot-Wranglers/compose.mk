{% import 'macros.j2' as macros -%}

## Import Services from Compose

<hr style="width:100%;border-bottom:3px solid black;">

One of the main features for `compose.mk` is a method for "importing" docker compose files into Makefiles.  This uses the `compose.import` macro to automatically generate several related make-targets for each docker-compose service.  Sometimes this "importing" process is referred to as *automation scaffolding*, or we might refer to it as *the make/compose bridge* or simply *the bridge*.

Let's walk through a minimal example, starting with a hypothetical compose file.  We'll use images for debian and alpine just as examples, but these might be any tool containers that your workflow requires.

```yaml 
# example docker-compose.yml
services:
  debian:
    image: debian
  alpine:
    image: alpine 
```

<hr style="width:95%;border-bottom:1px dashed black;">

Next, the Makefile.  To generate make-targets for every service in the given compose file, we just need to import the `compose.import` macro and call it.

```Makefile
# Inside your project Makefile
include compose.mk
$(eval $(call compose.import, ▰, TRUE, docker-compose.yml))
```

The arguments *`(▰, TRUE)`* above allow for control of the scaffolding's namespace and syntax.  *(More on that later in the [Macro Arguments section](#macro-arguments).)*  The final argument is just the (unquoted) name of the file you want to import services from.  

That's it for the minimal Make/Compose boilerplate, but we already have lots of interoperability for the containers involved.  This includes stuff like:

* The ability to quickly shell into these containers 
* The ability to trigger `docker compose` commands on them
* The ability to easily pass in data on pipes

See the next section for details about the autogenerated targets, or, if you're interested in running tasks inside of the compose-services skip ahead to the [container-dispatch section]({{mkdocs.site_relative_url}}/container-dispatch).

{# <hr style="width:95%;border-bottom:1px dashed black;">} #}

### Dynamic API

<hr style="width:100%;border-bottom:3px solid black;">

Targets created as part of the automation scaffolding fall into the following categories.

Assuming `compose.import` was allowed to import to the root namespace:

* [**`<svc_name>`**](#target-svc_name)
* [**`<svc_name>`/shell**](#target-svc_nameshell)
* [**`<svc_name>`/shell/pipe**](#target-svc_nameshellpipe)
* [**`<svc_name>`/get_shell**](#target-svc_namespecial)

So for our simple example so far, `svc_name` would be either `debian` or `alpine`.

Regardless of whether you're importing to the root namespace, you'll get "absolute paths" to similar targets that are created automatically.

* [**`<compose_stem>`.services**](#target-compose_stemspecial)
* [**`<compose_stem>`.build**](#target-compose_stemspecial)
* [**`<compose_stem>`.clean**](#target-compose_stemspecial)
* [**`<compose_stem>`/`<svc_name>`**](#target-svc_nameshell)

So for our example so far, `compose_stem` from `docker-compose.yml`would be `docker-compose`.

See the sections below for more concrete examples of what these targets can do.

<hr style="width:95%;border-bottom:1px dashed black;">}

#### **`<svc_name>`/shell** 

The **`<svc_name>`/shell** target drops to a containter shell for the named service, and is usually interactive.

```bash 

# Interactive shell on debian container
$ make debian/shell

# Interactive shell on "alpine" container
$ make alpine/shell
```

{{macros.img_link("demo-bridge-shell.gif", mkdocs)}}

<hr style="width:95%;border-bottom:1px dashed black;">

#### **`<svc_name>`/shell/pipe** 

The **`<svc_name>`/shell/pipe** target allows streaming data:

```bash
# Stream commands into debian container
$ echo uname -n -v | make debian/shell/pipe

# Equivalent to above, since the debian image's default entrypoint is bash
$ echo uname -n -v | make debian/pipe

# Streams command input / output between containers
echo echo echo hello-world | make alpine/pipe | make debian/pipe
```

{{macros.img_link("demo-bridge-stream.gif", mkdocs)}}

<hr style="width:95%;border-bottom:1px dashed black;">

#### **`<svc_name>`** 

The top-level **`<svc_name>`** target is more generic and can be used without arguments, or with optional explicit overrides for the compose-service defaults.  Usually this isn't used directly, but it's sometimes useful to call from automation. Indirectly, most other targets are implemented using this target.

```bash 
# Runs an arbitrary command on debian container (overriding compose defaults)
$ entrypoint=ls cmd='-l' make debian

# Streams data into an arbitrary command on alpine container
$ echo hello world | pipe=yes entrypoint=cat cmd='/dev/stdin' make alpine
```

<hr style="width:95%;border-bottom:1px dashed black;">

#### **`<svc_name>`/`<special>`**

Besides targets for working *with* services there are targets for answering questions *about* services.

The *`<svc_name>/get_shell`* targets answers what shell can be used as an entrypoint for the container. Usually this is `bash`, `sh`, or an error, but when there's an answer you'll get it in the form of an absolute path.

```bash

$ make debian/get_shell
/bin/bash
```

<hr style="width:95%;border-bottom:1px dashed black;">

#### **`<compose_stem>/<svc>`**

Namespaced aliases are also available, so that you can reference compose services by something like an "absolute path".  Due to the file-stem of the compose file we imported, all of the stuff above will work on targets like you see below. 

```bash
$ make docker-compose/debian
$ make docker-compose/debian/shell
```

<hr style="width:95%;border-bottom:1px dashed black;">

#### **`<compose_stem>`.`<cmd>`**

Besides targets for working with compose-services, some targets work on the compose file itself.  Assuming your compose file is named `docker-compose.yml`, the special targets work like this:

```bash 

# Build (equivalent to `docker compose -f docker-compose.yml build`)
make docker-compose.build

# Build (equivalent to `docker compose -f docker-compose.yml stop`)
make docker-compose.stop

# Clean (equivalent to `docker compose -f docker-compose.yml down --remove-orphans`)
make docker-compose.clean

# List all services defined for file (Array of strings, xargs-friendly)
make docker-compose.services
```

Using the `<compose_stem>.services` target, it's easy to map a command onto every container.  Try something like this:

```bash 
$ make docker-compose.services \
  | xargs -n1 -I% sh -x -c "echo uname -n \
  | make docker-compose/%/shell/pipe"
```

### Import Macro Arguments

<hr style="width:100%;border-bottom:3px solid black;">

Make isn't big on named-arguments, so let's unpack the typical `compose.import` macro invocation.

```Makefile
# your project Makefile

include compose.mk
$(eval $(call compose.import, ▰, TRUE, docker-compose.yml))
```

 **The 1st argument for `compose.import` is called `target_namespace`**.  You can swap the unicode for `▰` out, opting instead for different symbols, path-like prefixes, whatever.  If you're bringing in services from several compose files, one way to control syntax and namespacing is to use different symbols for different calls to `compose.import`.  (For a 2-file example, see the [Multiple Compose Files]({{mkdocs.site_relative_url}}/multiple-compose-files) section.)

**The 2nd argument for `compose.import` controls whether service names are available as top-level Makefile targets.**  The only value that means True is *`TRUE`*, because Make isn't big on bool types.  Regardless of the value here, service targets are always under `<compose_file_stem>/<compose_service_name>`. 

**The last argument for `compose.import` is the compose-file to load services from.**  It will be tempting to quote this and the other arguments, but that won't work, so resist the urge!

See also the docs for [container dispatch syntax/semantics]({{mkdocs.site_relative_url}}/container-dispatch/#dispatch-syntaxsemantics).

### Import Macro Implementation

<hr style="width:100%;border-bottom:3px solid black;">

For those unfamiliar with esoteric `make`, let's unpack the incantation: 

```Makefile 
$(eval $(call compose.import, ▰, TRUE, docker-compose.yml))
```

The [`eval`](https://www.gnu.org/software/make/manual/html_node/Eval-Function.html) / [`call`](https://www.gnu.org/software/make/manual/html_node/Call-Function.html) combination is how you make dynamic targets.  This is basically a code-generation step, where `compose.import` is a templated string, and then using `call` binds the values `( ▰, TRUE, docker-compose.yml)` as template parameters.  Since the templated string happens renders to legal Makefile syntax, the call to `eval` results in the declaration of new concrete targets.  

Metaprogramming in `make` like this is something that's guaranteed to inspire feelings of horror, or of delight.  If you're *that* type of weirdo, you might like to [read more about the technique[(https://make.mad-scientist.net/the-eval-function/).

<hr style="width:100%;border-bottom:3px solid black;">
