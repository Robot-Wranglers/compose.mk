{% import 'macros.j2' as macros -%}

## Loading Compose Files

For the simplest use-cases where you have a compose-file, and want some of the compose.mk features, but don't have a project makefile, it's possible to skip some of the steps in the [usual integration]({{mkdocs.site_relative_url}}/bridge) by letting `loadf` generate integration for you just in time.

```bash
$ ./compose.mk loadf <path_to_compose_file> <other_instructions>
```

## No arguments 

If no additional downstream targets are passed, the default behaviour is to open a shell for each tool container [using the TUI]({{mkdocs.site_relative_url}}/embedded-tui).  Here's what it looks like:

{{macros.img_link("tui-3.gif", mkdocs)}}

<hr style="width:100%;border-bottom:3px solid black;">

### Downstream Targets

Using `loadf` effectively runs [`compose.import`]({{mkdocs.site_relative_url}}/bridge) *for you* so that afterwards you can use any of the other targets documented as [part of the bridge]({{mkdocs.site_relative_url}}/bridge/#dynamic-api) or the [static targets]({{mkdocs.site_relative_url}}/api).

This means that `loadf` doesn't really need to involve the TUI at all.  The example below is using the [`<svc_name>/get_shell`]({{mkdocs.site_relative_url}}/bridge/#svc_namespecial) target:

{{macros.img_link("tui-4.gif", mkdocs)}}

Note that despite all the output **this is pipe-safe**, in case the commands involved might return JSON for downstream parsing, etc.  As another example, you can use the [<svc_name>/pipe]({{mkdocs.site_relative_url}}/bridge/#svc_nameshellpipe) with a command like this:

```bash
echo ls | ./compose.mk loadf tests/docker-compose.yml debian/shell/pipe
```

Ultimately though, using the TUI for quick and convenient inspection is probably the main use case.  Here's a few more examples along those lines:

```bash 
# Opens 3 panes with container-shells
$ ./compose.mk loadf tests/docker-compose.yml tux.mux.svc/debian,alpine,debian

# Equivalently, using lower-level generic targets
$ ./compose.mk loadf tests/docker-compose.yml tux.mux/debian/shell,alpine/shell,debian/shell

# Opens 2 panes of bash-shells for the TUI container itself
$ ./compose.mk loadf tests/docker-compose.yml tux.mux/io.bash,io.bash
```

See also the [Embedded TUI]({{mkdocs.site_relative_url}}/embedded-tui/#zero-config-tuis) docs for other examples that are using `loadf`.

<hr style="width:100%;border-bottom:3px solid black;">

{#
### Loadf Implementation 

Since `make` can't modify available targets from inside recipes, this basically works by creating temporary files that use the [compose.import macro]({{mkdocs.site_relative_url}}/macro-arguments) on the given compose file, then proxying subsequent CLI arguments over to *that* automation.  

<hr style="width:100%;border-bottom:3px solid black;">
#}