{% import 'macros.j2' as macros -%}
## Mad Science

<hr style="width:100%;border-bottom:3px solid black;">

### Polyglot Makefiles: Working with Foreign Languages

```Makefile
{{open('demos/elixir.mk','r').read().strip()}}
```
<hr style="width:95%;border-bottom:1px dashed black;">

### Local Interpretters without Containers

```Makefile
{{open('demos/local-interpretter.mk','r').read().strip()}}
```
<hr style="width:95%;border-bottom:1px dashed black;">

### Containerized Python + Deps

```Makefile
{{open('demos/uv.mk','r').read().strip()}}
```
<hr style="width:95%;border-bottom:1px dashed black;">

## Exotic Targets & Pipes

```Makefile
{{open('demos/exotic-targets.mk','r').read().strip()}}

```

{#
### How it Works 

Most of this stuff hinges on multi-line defines, plus the [ability of `compose.mk` to handle reflection](/standard-lib/#reflection-support), which is possible because it has some ability to parse its own contents.  

See the API for [*`mk.*`*]({{mkdocs.site_relative_url}}/api#api-mk) and [*`docker.*`*]({{mkdocs.site_relative_url}}/api#api-docker) for more details.  
Note also that the [*`mk.def.*`* targets]({{mkdocs.site_relative_url}}/api#api-mk) leave the data inside the defs completely unmolested, which means that there's no requirement for escaping the contents, and things like `$` are always left alone.  This also means the **content is fairly static**, and not typically amenable to pre-execution templating.  It *is* possible to work around this, but that's an even more crazy idea than the rest of this is, so it is left as an exercise to the reader. =P

<hr style="width:100%;border-bottom:3px solid black;">
#}

<hr style="width:100%;border-bottom:3px solid black;">
