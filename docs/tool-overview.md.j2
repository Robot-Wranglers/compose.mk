{% import 'macros.j2' as macros -%}

## Tool Overview

One of the major benefits of uising `make` over plain bash scripting is that lots of the details for CLI entrypoints are handled automatically.  In fact, **make-targets always do double-duty as CLI entrypoints and as reusable tasks.**  Tasks can be used on their own or mentioned as prerequisites and composed into DAGs, but no matter how you arrange things **the "internal API" is automatically published as a CLI interface.**  

Because of this basic duality, even the documentation for "programmatic" usage of `compose.mk` as a library tends to introduce or demonstrate concepts by using tool-mode first.  This means that even if you're not interested in `compose.mk` as a library.. the [library docs](#) and the [full API ](#) both have many examples that are relevant for stand-alone mode.  Just search for `./compose.mk` to find them.

If you're wondering how and why stand-alone mode can work in the first place: as long as `compose.mk` is an executable file, `./compose.mk ...` is equivalent to `make -f compose.mk ...`.

### Stand Alone Mode

Much of what `compose.mk` does is focused on helping you to [generate automation scaffolding]({{mkdocs.site_relative_url}}/bridge), but [that approach requires a pre-existing project and some integration / installation]({{mkdocs.site_relative_url}}/integration). 

**In Stand-alone Mode,** you can still use many of those features but skip the usual project integration.  In other words, no project Makefiles, and no external tool-container descriptions inside docker compose files.

This is less powerful and less flexible, but still results in a neat little swiss army knife that has some unique capabilities.  Most use-cases for stand-alone mode will fall into one of these categories:

1. **Using wrapped versions of common tools,** so that they can be used more quickly and more safely from more environments without adding more dependencies.  For example, `./compose.mk jq` defaults to using local executable if one is available, and falls back to a dockerized version of the tool otherwise.
1. **Loading compose files just-in-time.** This is a special case and [it has separate documentation & demos]({{mkdocs.site_relative_url}}/loadf), but basically the invocation `./compose loadf docker-compose.yml <optional_downstream_targets>` is similar to using a dedicated Makefile that [calls `compose.import`]({{mkdocs.site_relative_url}}/bridge).  Downstream targets can reference any of the autogenerated targets, and if no downstream targets are given, the default behaviouir is to open interactive shells for each tool container in a TUI.
1. **Cleaning up gnarly bash.**  In certain cases using `compose.mk` idioms can be easier to read and write.  For example, if your scripts are littered with `docker run ..` invocations, you might look at some of the [raw docker support]({{mkdocs.site_relative_url}}/vanilla-docker) for alternatives.

<hr style="width:100%;border-bottom:3px solid black;">

### Tool Wrappers

Some tools are so useful that we'd really like to assume they are available everywhere.  How can that happen though if we're not sure whether they are installed?  To address this, `compose.mk` publishes several tool-wrappers that default to using a local executable if one is available, and falls back to a dockerized version of the tool otherwise.  (In case you end up using dockerized tools, they are pulled just in time but cached afterwards.)

A few examples of tools that `compose.mk` wraps in one way or another include: 

* [jq](https://github.com/jqlang/jq), for querying JSON
* [jb](https://github.com/h4l/json.bash), for constructing JSON
* [yq](https://github.com/mikefarah/yq), for querying yaml and other stuff
* [charmbracelet/glow](https://github.com/charmbracelet/glow), for rendering markdown on console
* [charmbracelet/gum](https://github.com/charmbracelet/gum), for a variety of pretty text-formatting tricks
* [pygments](https://pygments.org/), for syntax highlighting data or code 
* [chafa](https://github.com/hpjansson/chafa), for rendering images on console
* [tmux](https://github.com/tmux/tmux) and friends, for console geometry management

<hr style="width:95%;border-bottom:1px dashed black;">

#### Proxy Wrappers

The first 3 tools `jq`, `jb`, and `yq` are the most generally useful.  They all have extensive documentation elsewhere to cover what they do and how to use them, and mostly `compose.mk` tries to stay out the way. Remember, the main point is to use the tool if possible, and transparently falls back to docker if the tool is missing.  Calling them with `compose.mk` looks like this:

```bash 
# Generate JSON with jb
$ ./compose.mk jb key=val
{"key":"val"}

# Generate JSON with jb (alternate)
$ echo key=val | ./compose.mk jb
{"key":"val"}

# Parse JSON with jq
$ ./compose.mk jb key=val | ./compose.mk jq .key
"val"

# Passing arguments to jq works, so lets go raw and unquote it
./compose.mk jb key=val | ./compose.mk jq -r .key
val

# Now try yaml input, with yq
$ echo "key: val" | ./compose.mk yq .key
```

So far so good.  What even is a "*proxy wrapper*" anyway? Well, the eagle-eyed reader will have noticed that it's kind of crazy that this actually works, because behind the scenes running `./compose.mk ...` is roughly the same as `make -f compose.mk ...`, and so you'd expect that the tail part of the command line is *arguments to make*.  And yet.. there is no make-target called `.key`.

Under the hood, invocations for proxy-wrappers begin with an actual make-target, but before `make` parses beyond that, execution is short-circuited, and the rest of the command-line is consumed and passed on to the tool.  Frankly, this part only works [because of certain insane magic]({{mkdocs.site_relative_url}}/signals) which is hard to recommend, but it's pretty useful as you see above and actually seems portable so far! ;)

Proxy-wrappers are very useful for simple stuff, but the wrapped tools `jq`, `yq`, and `jb` all have big surface area with a lot of edge-cases for optional arguments, loading files, with or without pipes.  **If your use-case involves lots of flags or nested quotes or something, *maybe don't assume that the wrapped invocation is 1:1 with the original tool*.**  There's only so much that can be done here for the standalone-mode for `compose.mk`, but note that [library-style usage is more flexible]({{mkdocs.site_relative_url}}/standard-lib/#structured-input-output).  

<hr style="width:95%;border-bottom:1px dashed black;">

#### Other Wrappers 

Setting aside the big 3 tools that use [proxy-wrappers](#proxy-wrappers), other wrappers are more simple because `compose.mk` gets tactical and won't even try to expose a 1:1 interface.  Sometimes we accept arguments, but mostly we just pass data on pipes.  

Here's a few examples:

```bash 
# Use `stream.chafa` to preview an image on the console with chafa
$ cat img.png | ./compose.mk stream.chafa

# Use `stream.chafa` to preview an image on the console with chafa (alternate)
$ cat img.png | ./compose.mk stream.img.preview

# Use `stream.glow` to preview markdown
$ cat README.md | ./compose.mk stream.glow

# Use `stream.glow` to preview markdown (alternate)
$ cat README.md | ./compose.mk stream.markdown.preview

# Use `stream.pygmentize` to syntax-highlight code with pygments (guess lexer)
$ cat Makefile | ./compose.mk stream.pygmentize

# Use `stream.pygmentize` to syntax-highlight code with pygments (explicit lexer)
$ cat Makefile | ./compose.mk stream.pygmentize lexer=Makefile

# Use `stream.json.pygmentize` to preview JSON (minified)
$ ./compose.mk jb key=val | ./compose.mk stream.json.pygmentize

# Use `stream.json.pygmentize` to preview JSON (expanded)
$ ./compose.mk jb key=val | ./compose.mk jq . | ./compose.mk stream.json.pygmentize

# Use `stream.peek` to preview data somewhere in the middle of a pipe and pass it on
$ ./compose.mk jb key=val | ./compose.mk stream.peek | ./compose.mk jq .

```

In the case of `tmux`, see the separate [documentation for the embedded TUI]({{mkdocs.site_relative_url}}/embedded-tui).For more examples with `pygments` and `glow`, see also [the documentation for file & stream previews]({{mkdocs.site_relative_url}}/standard-lib/#file-and-stream-previews).  For a demo involving `chafa`, see [this workflow example]({{mkdocs.site_relative_url}}/standard-lib/#workflow-example-etl).

<hr style="width:95%;border-bottom:1px dashed black;">

### Kung-Fu with Flux 

```bash
# Use `stream.nl.to.space` to convert newlines to spaces 
$ ls /tmp | ./compose.mk stream.nl.to.space
```

<hr style="width:95%;border-bottom:1px dashed black;">
<hr style="width:100%;border-bottom:3px solid black;">

{#
### Logging Facilities

{{macros.img_link("demo-io.gif", mkdocs, "90%")}}

<hr style="width:100%;border-bottom:3px solid black;">

### Workflow Support

* [Clean, refactor, or port existing bash script](#) towards something that's easier to read and write.

If you prefer to learn from examples, you might want to just [get started](#makecompose-bridge) or skip to the main [cluster automation demo](/demos#demo-cluster-automation) or to a [tui demo](#embedded-tui).  If you're the type that needs to hear the motivation first, read on in the next section.
#}
