# demos/makeception.mk: 
#   Demonstrates "makeception", where the details of a provisioning 
#   an embedded docker container are handled inside of `make` itself.
#
#   This demo ships with the `compose.mk` repository and runs as part of the test-suite.  
#
#   USAGE: make -f demos/makeception.mk


include compose.mk
.DEFAULT_GOAL := demo.makeception
export BUILD_TARGET?=none

demo.makeception: demo.provision demo.dispatch 

# Look it's an embedded compose file.  This defines services `alice` & `bob`.
define inlined.services
services:
  alice: &base
    hostname: alice
    build:
      context: .
      dockerfile_inline: |
        FROM debian/buildd:bookworm
        RUN apt-get update 
        COPY . /app
        RUN cd /app && make -f ${MAKEFILE} ${BUILD_TARGET}
    working_dir: /workspace
    volumes:
      - ${PWD}:/workspace
  bob:
    <<: *base
    hostname: bob
endef 

# After the inline exists, we can call `compose.import.def`,
# autogenerating target scaffolding for each service.
$(eval $(call compose.import.def,  ▰,  TRUE, inlined.services))

# We'll use the autogenerated targets for `<service_name>/build` to
# to trigger building each compose service explicitly.  The embedded
# compose file is structured so that each service is setup by using 
# `make`, but in each case the target is decided just in time.
demo.provision:
	BUILD_TARGET=alice.provision ${make} alice/build 
	BUILD_TARGET=bob.provision ${make} bob/build 

# Having different targets setting up alice and bob means 
# that the containers can have very different contents.  
# Again, these targets run *on the containers* at build-time, 
# not on the docker host! This allows us to keep `dockerfile_inline` 
# very small and generic.  It's nice that we don't have to prefix every 
# provisioning line  with "RUN ...", but the main benefit to deferring to 
# `make` for setup like this is the ability to do more complex scripting
# without hassle.
alice.provision:
	apt-get install -y figlet
bob.provision:
	apt-get install -y ack

# That's it for setup, let's test what's been made just to prove 
# that the provisioning steps worked and the containers are really 
# differentiated.  Here we use the autogenerated scaffolding that 
# was already built by `compose.import.def` to dispatch the 
# same `internal_task` target to run inside alice and bob.
demo.dispatch: ▰/alice/internal_task ▰/bob/internal_task
internal_task:
	echo "Running inside `hostname`"
	echo "Special tools available: `which figlet || which ack`"
